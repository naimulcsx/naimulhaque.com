---
title: "A Closer Look at the 'this' keyword in JavaScript"
publishedAt: "2023-04-15"
summary: "An exploration of the values of JavaScript's 'this' keyword in different contexts, aiming to provide a deeper understanding of its behavior."
---

The `this` keyword is a unique identifier in JavaScript whose value is determined by the context in which the code is being executed. The value of `this` is determined at runtime and can vary depending on the context it is being used. As a result, the behavior of the `this` keyword seems confusing to many people, especially those who are new to the language or have limited experience with its nuances.

This article aims to explore the values of the `this` keyword in different contexts. Let's dive in and unravel the mysteries of this keyword!

## Global context

In JavaScript, when the `this` keyword is used in the global context (i.e. outside any function or object method), its value refers to the global object.

### Global object

The global object is the top-level object in the scope chain and acts as a container for all global variables, functions, and objects.

In the browser environment, the global object is the `window` object. It provides access to various properties and methods related to the browser environment. For example, we all use the `window.document` object to access the DOM or `window.alert()` to display pop-up alerts.

```js
console.log(this === window); // true
console.log(console === window.console); // true
console.log(setTimeout === window.setTimeout); // true
```

In Node.js environment, the global object is `global` object, similar to how the `window` object is used in browsers but designed for server-side JavaScript execution.

```js
console.log(this === global); // true
console.log(this === global.setTimeout); // true
```

## Function context

When a function is called without a context, `this` is bound to the `global` object in non-strict mode, or `undefined` in strict mode.

```jsx
function sayHello() {
  // in non-strict mode, `this` refers to the `global` object
  console.log(`Hello, my name is ${this.firstName}`);
}

sayHello(); // Hello, my name is undefined
```

<Callout>
  When `sayHello()` is called in strict mode, this inside the function becomes
  `undefined` instead of referring to the global object. It will throw an error
  "Cannot read property 'name' of undefined".
</Callout>

## Explicit function binding

In some cases, explicitly binding the this keyword to a specific object is required to ensure that the function always operates with the correct context, regardless of how it is invoked.

We have three methods to accomplish this: `call`, `apply` and `bind` which we may call on any function. When a function is invoked with `call`, `apply` or `bind`, the `this` keyword is bound to the first parameter.

### Function.prototype.call()

In the following example, we're explicitly binding the `this` keyword to the `person` object. It takes the following input parameters:

- `thisArg`: The value to be passed as the this context within the function.
- `arg1`, `arg2`, ...: Optional arguments to be passed to the function individually.

```jsx
const person = { firstName: "Naimul" };
function sayHello(greet) {
  console.log(`${greet}, my name is ${this.firstName}`);
}
sayHello(); // Hi, my name is undefined
sayHello.call(person, "Hi"); // Hi, my name is Naimul
```

In this example, the `sayHello` function is called with the `call` method, which binds the `this` to the person object, so the output is "Hi, my name is Naimul".

### Function.prototype.apply()

The `apply` method is another method that allows you to call a function and explicitly set the this context, just like `call`. However, unlike `call`, `apply` takes arguments as an array or an array-like object. It takes the following input parameters:

- `thisArg`: The value to be passed as the this context within the function.
- `[arg1, arg2, ...]`: An array containing the arguments to be passed to the function.

```js
const person = { firstName: "Naimul" };
function sayHello(greet) {
  console.log(`${greet}, my name is ${this.firstName}`);
}
sayHello.apply(person, ["Hi"]); // Hi, my name is Naimul
```

### Function.prototype.bind()

Unlike `call` and `apply`, `bind` does not execute the function immediately but instead returns a new function where the `this` context is fixed to a specified object.

```js
const person = { firstName: "Naimul" };
function sayHello(greet) {
  console.log(`${greet}, my name is ${this.firstName}`);
}
const sayHelloWithPerson = sayHello.bind(person, "Hola");
sayHelloWithPerson();
```

Notice that, the `greet` parameter is pre-filled with "Hello".

## Object method binding

When a method is called on an object in JavaScript, the `this` keyword inside that method refers to the object itself. This behavior is known as _method binding_ and it's a fundamental aspect of how object-oriented programming works in JavaScript.

### Example

Let's look at the following example

```jsx
const person = {
  firstName: "Naimul",
  greet: function () {
    // this refers to the `person` object
    console.log(`Hello, my name is ${this.firstName}`);
  },
  printName: () => {
    console.log(this.firstName);
  },
};

person.greet(); // "Hello, my name is Naimul"
person.printName(); // undefined
```

<Callout>
  You'll notice that the `person.printName()` method returns `undefined` because
  the method is defined using an arrow function. Arrow functions behave
  differently than regular functions. The arrow function `printName` captures
  the this value from the surrounding scope, which, in this case, is the global
  scope (the outermost scope).
</Callout>

### Nested function

Let's moved the `console.log` in a nested function and call the function within the method. Trust me! We'll find out something interesting.

```jsx
const person = {
  firstName: "Naimul",
  greet: function () {
    function showGreetingMessage() {
      // `this` refers to the `global` object
      console.log(`Hello, my name is ${this.fullName}`);
    }
    showGreetingMessage();
  },
};

person.greet(); // "Hello, my name is undefined"
```

## Constructor functions

When a function is called as a constructor with the `new` keyword, `this` is bound to the newly created object. For example:

```jsx
// `this` refers to the newly created object which is returned by the new Person() call
function Person(name, age) {
  this.name = name;
  this.age = age;
}
const me = new Person("Naimul", 26);
console.log(me); // Person { name: 'Naimul', age: 26 }
```

## Within a nested function

```jsx
const myFriend = {
  fullName: "Tanveer Kader",
  greet: function () {
    const self = this;

    // inside the callback `this` refers to the `Timeout` object
    setTimeout(function () {
      console.log("inside callback", this === self);
    }, 0);

    // inside the getGreetingMessage `this` refers to the `global` object
    function showGreetingMessage() {
      console.log(`Hello, my name is ${this.fullName}`);
      console.log("inside nested function", this === self);
    }

    showGreetingMessage();
  },
};

myFriend.greet();
```

The value of `this` in the `getGreetingMessage()` function is the `global` object, because it is being invoked as a standalone function and not as a method of any object. It does not inherit the `this` value of the outer schop. To fix this issue, we can take several approach

- Storing the `this` variable in a `self` variable
- Calling the function with `call`, `bind` or `apply`
- Using arrow functions

To fix this, we&apos;ll convert our regular functions into arrow functions.

```jsx
const anotherPerson = {
  fullName: "John Doe",
  greet: function () {
    const self = this;

    setTimeout(() => {
      console.log("inside callback", this === self);
    }, 0);

    const showGreetingMessage = () => {
      console.log(`Hello, my name is ${this.fullName}`);
      console.log("inside nested function", this === self);
    };

    showGreetingMessage();
  },
};
anotherPerson.greet();
```

By changing these regular functions to arrow functions, the `this` value is no longer redefined within the function, and instead, it inherits the `this` value from the surrounding myFriend object. This allows the arrow functions to access the correct `this` value, which is the myFriend object, and fix the issue with `this` not pointing to the right object.

The topic of arrow functions is broad and can require its own in-depth exploration. In a future article, we can dive deeper into advanced concepts related to arrow functions, such as lexical scoping, handling of arguments, and best practices for their usage in different scenarios.

In conclusion, understanding the behavior of the `this` keyword in different contexts is crucial for writing effective JavaScript code. Arrow functions can be a powerful tool in maintaining the desired this value from an outer scope. However, it's important to be mindful of their limitations and use them appropriately.
